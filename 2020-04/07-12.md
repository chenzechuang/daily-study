# 2020-04-07
> 大致规划了基于目前自己的前端知识体系，还需要在接下来的时间去不断完善。

![前端知识体系](img/FF.png)

## 手写深拷贝

```javascript
  function deepClone (obj = {}) {
    if (typeof obj !== 'object' || obj == null) {
      return obj;
    }
    const target = Array.isArray(obj) ? [] : {};
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        target[key] = deepClone(obj[key]);
      }
    }
    return target;
  }
```
# 2020-04-08

> 今天系统地研究了浏览器缓存，基本上理解了浏览器缓存机制，包括缓存类型、缓存位置、缓存优先级及页面刷新对缓存的影响。

参考文章：  
[1] [深入理解浏览器的缓存机制](https://www.jianshu.com/p/54cc04190252)  
[2] [(1.6w字)浏览器灵魂之问，请问你能接得住几个？](https://juejin.im/post/5df5bcea6fb9a016091def69)

> 回流、重绘的学习总结

>  [慕课网-前端JavaScript面试技巧](https://coding.imooc.com/class/400.html)  3/4章 原型和原型链  作用域和闭包

## ES6语法 简易JQuery实现 ：

```javascript
class JQuery {
  constructor (selector) {
    const result = document.querySelectorAll(selector);
    for (let i = 0; i < result.length; i++) {
      this[i] = result[i];
    }
    this.length = length;
    this.selector = selector;
  }
  eq (index) {
    return this[index];
  }
  each (fn) {
    for (let i = 0; i < this.length; i++) {
      const elem = this[i];
      fn(elem);
    }
  }
  on (type, fn) {
    return this.each(elem => {
      elem.addEventListener(type, fn, false);
    })
  }
}
// 插件
JQuery.prototype.test = () => {
  console.log('test');
}
// 复写
class myJQuery extends JQuery {
  constructor(selector) {
    super(selector);
  }
  test () {
    console.log('test');
  }
}
```
## 闭包、自由变量、作用域

  - 闭包有两种表现形式

    - 函数作为参数被传递
    - 函数作为返回值被返回

  - 自由变量的查找，是在函数声明的地方，向上级作用域查找，不是在执行的地方。

## `this`指向 

`this的取值，是在函数执行时确定的`

  - 作为普通函数调用，严格模式下`this`指向`undefined`, 非严格模式下指向`window`

  - 使用`call`/`apply`/`bind`调用，this指向第一个参数绑定的对象

  - 当函数作为对象方法被调用，this指向调用的对象

  - 通过构造函数调用，this指向新创建的对象

  - 在箭头函数中，this是箭头函数上级作用域的this

## 手写call/apply/bind
